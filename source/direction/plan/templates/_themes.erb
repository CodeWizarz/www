### Enterprise planning frameworks support

Our vision is to build a Plan experience that aligns with our [configuration principles](https://about.gitlab.com/handbook/product/product-principles/#configuration-principles). When you look across the Enterprise Agile Planning tool landscape, you'll find solutions with large customer bases that cover many methodologies and personas. Our competitors have built highly flexible solutions with many configuration options to accommodate the large array of use cases. Unfortunately, this makes these tools non-performant and challenging to administer, leading to customer dissatisfaction.

There are now countless solutions that aim to make planning tools that teams love. For example, tools like Notion, Monday.com, and Asana simplify configuration and focus on user experience. We will follow a similar approach, but our differentiation will be an experience geared toward enabling DevSecOps organizations to optimize their [agile fluency](https://martinfowler.com/articles/agileFluency.html).

As examples, GitLab will provide:
* Out of the box functionality that allows DevSecOps teams to follow Scrum, Kanban, and Requirements-based development processes.
   * Work Items that represent discrete units of work and are typically used by single teams. Today we use Issues to represent work but we plan to [standardize on an underlying common model](https://docs.gitlab.com/ee/development/work_items.html) and introduce more work item types. Examples of team work items types are Stories, Bugs, and Requirements.
   * Views to facilitate Plan workflows for personas that work in a single team, like Engineers, UX, Product, and Engineering Managers. Example workflows are iteration planning, status views for a single team, and retrospectives.
* Out of the box functionality that aligns to industry-standard program and portfolio management, including frameworks like [SAFe](https://www.scaledagileframework.com), [LeSS](https://less.works), and [Disciplined Agile](https://www.pmi.org/disciplined-agile).
   * Work Items that represent collections of units of work and are typically used by multiple teams. Today we use Epics to represent collections of units of work but we plan to [standardize on an underlying common model](https://docs.gitlab.com/ee/development/work_items.html) and introduce additional portfolio level work item types. Examples of portfolio level work item types are Features, Epics, Themes, and OKRs.
   * Views to facilitate Plan workflows for personas that work across teams, like Program Managers, Managers of Managers, and Executives. The ability to relate and roll up work items across projects and groups will be critical for these personas. Example workflows are quarterly or program increment planning, status reporting across multiple teams, and retrospectives across multiple teams.
* Options to customize the data captured about work items and their status. We currently rely on labels for this information, but our customers have expressed the need for a more structured approach. A lightweight custom data solution in GitLab has the ability to enable a wide range of use cases such as prioritization models and CapEx reporting.

We have strong signals from our customers that they want a planning tool that supports their processes but is not overbearing. Recent conversations include:
* An industry leading telecommunications company that wants to consolidate multiple planning tools into GitLab. Their current setup has complicated enforced workflows and data integrations that make their tools difficult to use.
* A bank that is migrating their teams to GitLab, leaving behind their current highly customized planning tool. Our plan capabilities are lighter weight, increase developer productivity, and encourage collaboration.

#### Work Items Framework - Under Construction
To achieve this vision, we are creating a new [framework](https://docs.gitlab.com/ee/development/work_items.html) that will be used to implement all existing planning items in GitLab and can be extended to allow more types in the future. The new work items framework is more flexible and scalable than the implementation we have today for Issues and Epics. Building a new framework that can house all existing planning items means that we will have greater consistency and feature parity between different types of planning items in the future. 
One downside of this approach is that it will require migrating existing planning items into something new, and our users will feel temporary discomfort from the change. Since we are building the work items framework to align with the future vision, our users may see differences and inconsistencies between Issues, Epics and other Work Item Types. For example, we have updated the label selector in work items to address feedback about the multi-level selection workflow in Issues being cumbersome. We believe the benefits of consolidating into a new framework built with the future in mind will be worth the temporary discomfort while it is [under construction](https://handbook.gitlab.com/handbook/values/#under-construction).

Ideally we will avoid any changes in legacy issue and epic, however when the need arises we will discuss and decide if we need to prioritize any work to address usability issues to continue meeting user expectations. All members of the [quad](https://about.gitlab.com/handbook/engineering/quality/quality-engineering/quad-planning/) will be involved in that discussion. 
We will move existing planning items to the new framework striving to [impact the fewest users possible](https://handbook.gitlab.com/handbook/values/#start-off-by-impacting-the-fewest-users-possible). For example, instead of migrating Issues or Epics, we introduced Tasks as the first work item type to validate the framework. We will continue to make usability improvements to the work items framework to ensure it meets user expectations. We are committed to minimizing the transition pain for our users and consolidating the experience for Epics, Issues, and Tasks into work items as quickly as possible, with a target of EOY FY24.

### Use DevSecOps data to optimize planning

As an end-to-end DevSecOps platform, GitLab is uniquely positioned to deliver a planning suite that enables business leaders to drive their vision and empower their development teams to work efficiently. Our unification of the DevSecOps process allows us to interlink data across every stage of development, from initial analysis to planning, implementation, deployment, and monitoring. Today, few teams can answer how long their software projects take, and even fewer can answer how long each stage in the process takes. Without this information, most teams are flying blind on their estimates, using past experiences and best guesses to best calculate the time or level of effort that it will take to get from an idea to production.
Engineering and product managers need to parse through information in multiple systems to know if problems will keep their teams from meeting their plans. The data is often hard to understand, so engineers' days are interrupted with requests for status updates. Executives rely on status reports that are created manually and often inaccurate. To fully solve this problem, DevSecOps data should be displayed so that it's easy to understand for users that are not developers.

As examples, GitLab will:
* Roll-up reports and dashboarding that provide visibility into where to focus next on improving performance and reliability includes:
   - Value stream dashboard to allow all stakeholders, from executives to individual contributors, to have visibility in the process and value delivery metrics associated with the software development life cycle. The Value stream dashboard enables teams to continuously improve workflows by benchmarking key DevSecOps metrics and comparing these metrics over time to identify and fix engineering inefficiencies and bottlenecks.
   - Everyday analytics for teams: Increasing the effectiveness and efficiency of everyday software development teams â€” surfacing actionable insights, identifying bottlenecks, and highlighting waste.
* Leverage data from other DevSecOps stages to provide context to non-technical users in work items; enabling them to derive the current status of work.
* Flag work items that are at risk during an iteration based on [DORA key metrics](https://docs.gitlab.com/ee/user/analytics/ci_cd_analytics.html#DevSecOps-research-and-assessment-dora-key-metrics) and [Value Stream Analytics](https://docs.gitlab.com/ee/user/group/value_stream_analytics/).
* Incorporate data from [DORA key metrics](https://docs.gitlab.com/ee/user/analytics/ci_cd_analytics.html#DevSecOps-research-and-assessment-dora-key-metrics) and [Value Stream Analytics](https://docs.gitlab.com/ee/user/group/value_stream_analytics/) into retrospective workflows.

### Automation, Artificial Intelligence and Machine Learning to improve quality of life

Managing issues across an organization can be a time-consuming and tedious endeavor. It's normal for organizations to have a large number of stale issues that require manual clean-up. Our focus will be to let automation do the lower value work like managing status changes and automating the movement of work items among workstations (queues) so the people doing the work can focus more on creating value and less on remembering the process. At GitLab, we dogfood our issue tracker and have implemented a considerable amount of [automation](https://gitlab.com/gitlab-org/gitlab-triage) to start down this direction. We will double down on this strategy, incorporate automation into our product and reduce the manual setup required to enable it. GitLab can also provide suggestions and nudges that reduce the number of actions required to complete common tasks.

GitLab has recently created [AI-powered stage](https://about.gitlab.com/direction/ai-powered/) and the Plan Stage has been collabrating with that stage to bring new AI-powered Planning capabilities.

As examples, GitLab will provide:
* Assistance in generating text for work items like issues and epics.
* Auto-assign issues based on previous assignments.
* Auto-close or suggest closing issues if downstream activity implies it.
* Apply labels automatically based on historical issue data.
* Change issue health if downstream DevSecOps activity implies it.
* Surface, categorize and rank work items that may need a user's attention.
* Optimize everyday manual actions like work item data entry or updates by providing real-time suggestions.
