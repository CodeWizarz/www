---
title: "Using Gitlab APIs: Real Use Case Scenario"
author: William Arias
author_gitlab: warias
author_twitter: WilliamAriasZ
categories: unfiltered
image_title: '/images/blogimages/gitlab-apis-ci/gitlabapi-cover.jpg'
description: "Learn about how GitLab CI and APIs can help you automate bulk tasks"
tags: CI, API, DevOps, demo
cta_button_text: 'Watch GitLab CI capabilities demo!' # optional
cta_button_link: 'https://youtu.be/zdBwMHARkU0?t=469'
guest: false
ee_cta: false # required only if you do not want to display the EE-trial banner
install_cta: false # required only if you do not want to display the 'Install GitLab' banner
twitter_text: "" # optional;  If no text is provided it will use post's title.
postType: content marketing # i.e.: content marketing, product, corporate
merch_banner: merch_one
merch_sidebar: merch_one
---

{::options parse_block_html="true" /}



Gitlab APIs along with  Continuous Integration can be very helpful when executing certain bulk tasks.

Consider this requirement derived from a real-world scenario

* Company XYZ possess several repositories that have been organized under a Gitlab group

![group](/images/blogimages/gitlab-apis-ci/gitlab-group.png){: .shadow.medium.center.wrap-text}

* The company needs to test the building of projects in bulk using new  hardware (Runner with different CPU Architecture) that will bring down  execution costs, whenever the build in each of the projects fails an issue must be  automatically created.

![runner](/images/blogimages/gitlab-apis-ci/runner.png){: .shadow.medium.center.wrap-text}

* Lastly, all the issues that were automatically created whenever a project built failed,  should be collected in bulk and reported back to a Wiki

![pipelineview](/images/blogimages/gitlab-apis-ci/3-pipelineview-collect-issues.png){: .shadow.medium.center.wrap-text}

How do we test the building of those several projects and create issues and reports about its execution automatically? Let's use Gitlab CI and  APIs.


## 1. Company groups and projects Structure

In this case, the set of projects were grouped under a single group, following this structure:

![groupview](/images/blogimages/gitlab-apis-ci/4-group-view-api-blog.png){: .shadow.medium.center.wrap-text}

## 2. Automatically creating Issues leveraging Gitlab CI and API

In order to create issues using Gitlab API we will use the Issues API an example of that  can use the following cURL command:

![curl](/images/blogimages/gitlab-apis-ci/5-create-issue-api-gitlabapi.png){: .shadow.medium.center.wrap-text}

The API Call: 

 `curl --request POST --header "PRIVATE-TOKEN:$ISSUE_API_KEY" "https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/issues?title=Build%20Failed&labels=ARMbuild&description=Project%20Tests%20Failed%20on%20ARM"`

 The previous Gitlab API call can be configured to be executed whenever a job fails. Let's dissect this API Call to understand its parameters so you can potentially customize it  for your project environment

* Base URL:  https://gitlab.com/api/v4/projects
* Project where we want to add the issue:  $CI_PROJECT_ID Notice this ID is unique and corresponds to the project where the CI/CD pipeline runs 
* Issues: Endpoint we use to tell Gitlab we want to add an issue to the project
* Parameters:
  * Title: How we want the issue to be titled
  * Labels: Helpful to group issues by label or type, They help you organize and tag your work so you can track and find the work items you’re interested in.
  * Description: Field to explain the nature of the issue if needed

 The request is of type POST, because we are sending data to our receiver service.  For this call to be successful it requires  authentication for which we will use *PRIVATE-TOKEN* header

 The private token can be generated by following these steps [How-to-generate-token](https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html)

When we execute the above API call, we create an issue in the corresponding Gitlab project
![issueproject](/images/blogimages/gitlab-apis-ci/5-issues-created.png){: .shadow.medium.center.wrap-text}

Great, so once the multi-project pipeline has run,  each of the projects that failed in its building stage will create an issue warning us to double check why it failed while documenting the failure and labeling it for future follow-up.
![multiproject](/images/blogimages/gitlab-apis-ci/7.1-multiproject-pipeline-gitlabapi.png){: .shadow.medium.center.wrap-text}

## 3. Automatically collecting all the issues from Gitlab Group

Thanks to Gitlab CI and APIs we can collect all the issues created and report them back, by adding this script  in  your pipeline stage

![collectissues](/images/blogimages/gitlab-apis-ci/7-collecting-issues-apiblog.png){: .shadow.medium.center.wrap-text}

Let's dissect again the main API call:

`curl --header "PRIVATE-TOKEN:$GROUP_ISSUE_LIST" "https://gitlab.com/api/v4/groups/9123625/issues`

* Base url: https://gitlab.com/api/v4/
* Group resource: /groups/9123625
* Issues resources: /issues 

The previous API call will return a json object, the one we will save as an artifact when executing our pipeline job. Notice this artifact is created and saved automatically by Gitlab CI
Great! So far we created issues per failed project, and collected them all in one single step


## 4. Reporting back to Wiki Project 

![wikijob](/images/blogimages/gitlab-apis-ci/8-reportwiki-gitlab-api.png){: .shadow.medium.center.wrap-text}

For convenience, the json report was transformed to markdown, then using the following script we publish the markdown report to the Wiki of an specific project

`curl --data "format=markdown&title=$CI_JOB_ID&content=$results" --header "PRIVATE-TOKEN:$API_WIKI" "https://gitlab.com/api/v4/projects/20852684/wikis"`

Let's breakdown again the API call:

* Base url: https://gitlab.com/api/v4/
* Project resource ID : /projects/20852684
* Wiki resource: /wiki
* Parameters: 
  * Data format: markdown. We want to publish a markdown table
  * Title: Title of the Wiki entry, we use the environment variable corresponding to the CI_JOB that was executed
  * Content: The markdown table generated with the issues collection

 Finally, when the last API call has been executed, this is an example of the output we can get: 

 ![report](/images/blogimages/gitlab-apis-ci/10-test-report-gitlabapi.png){: .shadow.medium.center.wrap-text}

Let's recapitulate, by using Gitlab CI in a multi project pipeline along with APIs we were able to test and report automatically x-number of projects and its compatibility with a new hardware CPU architecture. More information about the APIs utilized for this project here:

[Issues-api](https://docs.gitlab.com/ee/api/issues.html#new-issue)
[Collect-group-issues](https://docs.gitlab.com/ee/api/issues.html#list-group-issues)
[WikisAPI](https://docs.gitlab.com/ee/api/wikis.html)

[Multi-project-pipeline](https://about.gitlab.com/blog/2019/07/24/cross-project-pipeline/)


If you’d like to see GitLab’s API in action, watch this [video](https://youtu.be/zdBwMHARkU0?t=469).

For more information, visit [LEARN@GITLAB](https://about.gitlab.com/learn/).

Cover image credit:

Cover image by [Mohanan](https://unsplash.com/photos/yQpAaMsQzYE) on [Unsplash](https://unsplash.com)
{: .note}

