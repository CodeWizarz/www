---
title: "The business impact of CI/CD"
author: Chrissie Buchanan and William Chia
guest: true
author_twitter: gitlab
categories: insights
image_title: '/images/blogimages/modernize-cicd.jpg'
description: "How a good CI/CD strategy generates revenue and keeps developers happy."
tags: DevOps, CI/CD, workflow
cta_button_text: 'Explore GitLab CI/CD'
cta_button_link: '/features/continuous-integration/'
twitter_text: "Good CI/CD is a revenue generator. See how"
postType: content marketing
---

[Continuous integration and delivery](/features/continuous-integration/) helps [DevOps](/topics/devops/) teams ship higher quality software, faster. But is all [CI/CD](/topics/ci-cd/) created equal? What does successful CI/CD implementation look like and how do you know you’re on the right track?

In this four-part series, we talk about modernizing your CI/CD: Challenges, impact, outcomes, and solutions. In [part one](/blog/2019/06/05/modernize-your-ci-cd/), we focused on common CI/CD challenges. Today, we’ll talk about the revenue impact of a poor or non-existent CI/CD strategy.

If these problems hit a little too close to home, stay tuned for part three where we dive deeper into what organizations gain when they implement better CI/CD.

## What are the business impacts of bad CI/CD?

### 1. A large portion of IT budget is spent on undifferentiated engineering

Opportunity costs play a much larger role in the development process than we realize. Organizations can only afford so many engineers at one time, and systems that require extensive maintenance means fewer engineers are working on revenue-generating projects. This will lead to slower innovation and slower growth in the long term. Undifferentiated engineering means too many individuals are having to focus on one thing – maintenance.

### 2. Delayed (and even unrealized) revenue

This is the impact of lost opportunity costs. When there are too many dependencies, too many handoffs, and too many manual tasks, it causes delays between when code is written and when the business gets value from that code. In worst cases, code is written and the business never gets any value from it at all. Code can sit in limbo waiting for others to manually test it, and by the time it’s finally reviewed it’s already irrelevant. The opportunity cost essentially doubles: Engineers were paid to work on code that never deployed, and the business loses out on revenue the code could have generated.

### 3. Lower developer productivity, lower developer happiness, and less reliable software

Downtime = lost revenue. To avoid that dreaded downtime, developers are spending time working on infrastructure and configuration, and they’re also not spending that time delivering business logic. In both cases, they’re being less productive and working outside of their core competencies. Developer hiring and retention will inevitably suffer. Uptime and resiliency are also affected because people who aren’t domain experts are put in charge of determining infrastructure. It’s a self-fulfilling prophecy.

## What does it look like if a magic wand were to solve it today?

### 1. More engineers are working on the app instead of maintenance

The organization has the right amount of developers devoted to driving business value and spends more time on innovation instead of undifferentiated heavy lifting. Less of the budget is spent on activities that don't generate revenue.

### 2. Developers see their code in production quickly

Infrastructure and deployment are [fully automated](/stages-devops-lifecycle/auto-devops/). Everyone loves to see the output of their work, developers especially, and the business gets to see the benefits of this code right away. Deploying smaller chunks of code is less risky when developers can take advantage of test automation, so they have less overhead and coordination with a QA team forced to test manually.

### 3. Developers are focused on solving business problems

Code is written to be environment and cloud agnostic. Development teams own the uptime of their own services, but they are fully supported by the ops team. Ops owns the infrastructure, dev owns the service, and both teams can work according to their strengths.

Solving these problems doesn’t require waving a wand or any magic at all. Modernizing your architecture and embracing CI/CD is what other companies are doing to release better software, faster. When organizations implement CI/CD best practices, they get the added benefit of generating more revenue in the long run.

So what makes “good” CI/CD? We invite you to compare GitLab CI/CD to other CI tools and see why we were rated #1 in the Forrester CI Wave™.

[Explore GitLab CI/CD](/features/continuous-integration/)
{: .alert .alert-gitlab-purple .text-center}

Photo by [Jungwoo Hong](https://unsplash.com/photos/cYUMaCqMYvI?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/search/photos/arrow?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
{: .note}
