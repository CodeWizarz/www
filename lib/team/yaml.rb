require 'yaml'
require 'pathname'

require_relative './org_chart'

module Gitlab
  module Homepage
    class Team
      InconsistentTeamError = Class.new(StandardError)
      WrongPlaceError = Class.new(InconsistentTeamError)
      BadFilenames = Class.new(InconsistentTeamError)
      BadOrgChart = Class.new(InconsistentTeamError)
      BadTeamMembers = Class.new(InconsistentTeamError)
      ForbiddenField = Class.new(InconsistentTeamError)

      class Yaml
        HEADER = <<~HDR.freeze
          # Reach out to the following teams before making any
          # structural changes to this file as it's used for
          # downstream reporting:
          # - People Team
          # - Data Team
          #
          # THIS FILE IS AUTOMATICALLY GENERATED!
          # DO NOT EDIT THIS FILE. INSTEAD EDIT THE SOURCE FILES IN data/team_members/
          # GENERATED WITH: bundle exec rake build:team_yml
        HDR

        attr_reader :base_dir

        def initialize(base_dir = File.expand_path('../../data', __dir__))
          @base_dir = Pathname.new(base_dir).expand_path
        end

        def file_path
          base_dir + 'team.yml'
        end

        def directory
          base_dir + 'team_members' # must NOT be 'team', otherwise middleman tries to merge them
        end

        def join
          to_file(file_path, build_team, HEADER)
        end

        def to_yaml
          YAML.dump(build_team)
        end

        def verify_members!
          new_team = build_team
          new_slugs = new_team.map { |person| person['slug'] }

          verify_slugs!(new_slugs)
          verify_no_duplicates!(new_slugs, new_team)
          verify_org_chart!(new_team)
        end

        def verify!
          team = load_team
          new_team = build_team
          team_slugs = team.map { |person| person['slug'] }.to_set
          new_slugs = new_team.map { |person| person['slug'] }.to_set

          verify_slugs!(team_slugs | new_slugs)

          return if sort_team(team) == new_team

          slugs_only_in_team = new_slugs.empty? ? team_slugs : team_slugs - new_slugs
          slugs_only_in_new  = team_slugs.empty? ? new_slugs : new_slugs - team_slugs

          msg = if slugs_only_in_team.any? || slugs_only_in_new.any?
                  <<~MSG
                    Team members do not match.

                    Slugs only in #{file_path}:
                    #{slug_list(slugs_only_in_team)}

                    Slugs only in #{directory}:
                    #{slug_list(slugs_only_in_new)}
                  MSG
                else
                  indexed_team = team.group_by { |person| person['slug'] }
                  mismatches = new_team.reject do |person|
                    person == indexed_team[person['slug']].first
                  end

                  <<~MSG
                    The following team members do not have matching entries:

                    #{mismatches.map { |person| " - #{person['slug']} (#{person['name']}) " }.join("\n")}
                  MSG
                end

          raise Gitlab::Homepage::Team::InconsistentTeamError, msg
        end

        def org_chart
          Gitlab::Homepage::OrgChart.new(build_team)
        end

        def build_team
          @build_team ||= begin
            team = directory.glob('person/**/*.yml').map do |path|
              person = from_file(path)
              team_member(path, person)
            end

            verify_slugs!(team.map { |m| m['slug'] })

            sort_team(team)
          end
        end

        private

        def slug_list(slugs)
          slugs.map { |s| " - #{s}" }.join("\n")
        end

        def load_team
          from_file(file_path) || []
        end

        def sort_team(team)
          team&.sort_by do |person|
            [person['slug']]
          end
        end

        def from_file(path)
          YAML.load_file(path) if path.exist?
        end

        def to_file(path, obj, header = nil)
          path.open('w') do |io|
            io.write(header) if header
            YAML.dump(obj, io)
          end
        end

        def verify_org_chart!(team)
          org = Gitlab::Homepage::OrgChart.new(team)

          errs = org.validate

          return if errs.none?

          raise BadOrgChart, errs.join("\n\n")
        end

        def verify_no_duplicates!(slugs, team)
          return if slugs.to_set.size == team.size

          duplicates = slugs
            .group_by(&:itself).transform_values(&:count)
            .select { |k, v| v > 1 }
            .keys

          msg = <<~MSG
            Duplicate slugs found in the team directory:
            #{slug_list(duplicates)}
          MSG

          raise InconsistentTeamError, msg
        end

        def verify_slugs!(slugs)
          bad_slugs = slugs.reject do |s|
            s && s.tr(' ', '-').downcase == s && s.size > 1
          end

          return if bad_slugs.empty?

          msg = <<~MSG
            Bad filenames found.

            All filenames must be lower case, and not have spaces.

            Permitted characters: a-z, 0-9, _ - only

            An example of a good filename is: "foo.yml"
            An example of a bad filename is: "Wibble Bar.yml"

            Filenames that failed validation:
            #{bad_slugs.map { |s| " - `#{s}.yml`" }.join("\n")}
          MSG

          raise BadFilenames, msg
        end

        def team_member(path, person)
          slug = path.sub_ext('').basename.to_s
          index_dir = path.dirname.basename.to_s
          expected_index_dir = slug[0]
          type_dir_path = path.dirname.dirname

          (type, placed_correctly) =
            if index_dir == 'vacancy'
              ['vacancy', true]
            else
              ['person', index_dir == expected_index_dir]
            end

          raise WrongPlaceError, <<~MSG unless placed_correctly
            #{person['name']} (#{slug}) is in the wrong place.

            We found them at #{path}, but we expected them to be in #{type_dir_path + expected_index_dir}.
          MSG

          raise ForbiddenField, <<~MSG if person.key?('slug')
            #{person['name']} (#{slug}.yml) has a 'slug' in the file body.

            Slugs are inferred from filenames. Do not include a 'slug' field.
          MSG

          raise ForbiddenField, <<~MSG if person.key?('type')
            #{person['name']} (#{slug}.yml) has a 'type' in the file body.

            Types are inferred from the directory. Do not include a 'type' field.

            Instead, place this file either in
            data/team_members/person or data/team_members/vacancy
          MSG

          { 'slug' => slug, 'type' => type }.merge(person)
        end
      end
    end
  end
end
